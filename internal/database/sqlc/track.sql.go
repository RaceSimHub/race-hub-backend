// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: track.sql

package sqlc

import (
	"context"
	"time"
)

const deleteTrack = `-- name: DeleteTrack :exec
DELETE FROM
    track
WHERE
    id = $1::BIGINT
`

func (q *Queries) DeleteTrack(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteTrackStmt, deleteTrack, id)
	return err
}

const insertTrack = `-- name: InsertTrack :one
INSERT INTO track (
    name,
    country,
    fk_created_by_user_id
) VALUES (
    $1::VARCHAR,
    $2::VARCHAR,
    $3::BIGINT
) RETURNING id
`

type InsertTrackParams struct {
	Name              string
	Country           string
	FkCreatedByUserID int64
}

func (q *Queries) InsertTrack(ctx context.Context, arg InsertTrackParams) (int64, error) {
	row := q.queryRow(ctx, q.insertTrackStmt, insertTrack, arg.Name, arg.Country, arg.FkCreatedByUserID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const selectListTracks = `-- name: SelectListTracks :many
SELECT
    id::BIGINT,
    name::VARCHAR,
    country::VARCHAR,
    created_date::TIMESTAMP,
    updated_date::TIMESTAMP
FROM
    track
OFFSET $1::INTEGER
LIMIT $2::INTEGER
`

type SelectListTracksParams struct {
	Column1 int32
	Column2 int32
}

type SelectListTracksRow struct {
	ID          int64
	Name        string
	Country     string
	CreatedDate time.Time
	UpdatedDate time.Time
}

func (q *Queries) SelectListTracks(ctx context.Context, arg SelectListTracksParams) ([]SelectListTracksRow, error) {
	rows, err := q.query(ctx, q.selectListTracksStmt, selectListTracks, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SelectListTracksRow{}
	for rows.Next() {
		var i SelectListTracksRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Country,
			&i.CreatedDate,
			&i.UpdatedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTrack = `-- name: UpdateTrack :exec
UPDATE track SET
    name = COALESCE($1::VARCHAR, name),
    country = COALESCE($2::VARCHAR, country),
    fk_updated_by_user_id = $3::BIGINT
WHERE 
    id = $4::BIGINT
`

type UpdateTrackParams struct {
	Name              string
	Country           string
	FkUpdatedByUserID int64
	ID                int64
}

func (q *Queries) UpdateTrack(ctx context.Context, arg UpdateTrackParams) error {
	_, err := q.exec(ctx, q.updateTrackStmt, updateTrack,
		arg.Name,
		arg.Country,
		arg.FkUpdatedByUserID,
		arg.ID,
	)
	return err
}
