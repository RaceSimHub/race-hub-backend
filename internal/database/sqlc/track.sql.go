// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: track.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const deleteTrack = `-- name: DeleteTrack :exec
DELETE FROM
    track
WHERE
    id = $1::BIGINT
`

func (q *Queries) DeleteTrack(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteTrackStmt, deleteTrack, id)
	return err
}

const insertTrack = `-- name: InsertTrack :one
INSERT INTO track (
    name,
    country,
    fk_created_by_user_id
) VALUES (
    $1::VARCHAR,
    $2::VARCHAR,
    $3::BIGINT
) RETURNING id
`

type InsertTrackParams struct {
	Name              string
	Country           string
	FkCreatedByUserID int64
}

func (q *Queries) InsertTrack(ctx context.Context, arg InsertTrackParams) (int64, error) {
	row := q.queryRow(ctx, q.insertTrackStmt, insertTrack, arg.Name, arg.Country, arg.FkCreatedByUserID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const selectListTracks = `-- name: SelectListTracks :many
SELECT
    id::BIGINT,
    name::VARCHAR,
    country::VARCHAR
FROM
    track
WHERE 
    CASE WHEN $3::VARCHAR != '' THEN 
        name ILIKE '%' || $3 || '%' OR
        country ILIKE '%' || $3 || '%'
    ELSE
        TRUE
    END
ORDER BY
    id DESC
OFFSET $1::INTEGER
LIMIT $2::INTEGER
`

type SelectListTracksParams struct {
	Column1 int32
	Column2 int32
	Search  string
}

type SelectListTracksRow struct {
	ID      int64
	Name    string
	Country string
}

func (q *Queries) SelectListTracks(ctx context.Context, arg SelectListTracksParams) ([]SelectListTracksRow, error) {
	rows, err := q.query(ctx, q.selectListTracksStmt, selectListTracks, arg.Column1, arg.Column2, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SelectListTracksRow{}
	for rows.Next() {
		var i SelectListTracksRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Country); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectListTracksCount = `-- name: SelectListTracksCount :one
SELECT
    COUNT(*) AS count
FROM
    track
WHERE 
    CASE WHEN $1::VARCHAR != '' THEN 
        name ILIKE '%' || $1 || '%' OR
        country ILIKE '%' || $1 || '%'
    ELSE
        TRUE
    END
`

func (q *Queries) SelectListTracksCount(ctx context.Context, search string) (int64, error) {
	row := q.queryRow(ctx, q.selectListTracksCountStmt, selectListTracksCount, search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const selectTrackById = `-- name: SelectTrackById :one
SELECT
    id::BIGINT,
    name::VARCHAR,
    country::VARCHAR,
    created_date::TIMESTAMP,
    updated_date
FROM
    track
WHERE
    id = $1::BIGINT
`

type SelectTrackByIdRow struct {
	ID          int64
	Name        string
	Country     string
	CreatedDate time.Time
	UpdatedDate sql.NullTime
}

func (q *Queries) SelectTrackById(ctx context.Context, dollar_1 int64) (SelectTrackByIdRow, error) {
	row := q.queryRow(ctx, q.selectTrackByIdStmt, selectTrackById, dollar_1)
	var i SelectTrackByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Country,
		&i.CreatedDate,
		&i.UpdatedDate,
	)
	return i, err
}

const updateTrack = `-- name: UpdateTrack :exec
UPDATE track SET
    name = COALESCE($1::VARCHAR, name),
    country = COALESCE($2::VARCHAR, country),
    fk_updated_by_user_id = $3::BIGINT
WHERE 
    id = $4::BIGINT
`

type UpdateTrackParams struct {
	Name              string
	Country           string
	FkUpdatedByUserID int64
	ID                int64
}

func (q *Queries) UpdateTrack(ctx context.Context, arg UpdateTrackParams) error {
	_, err := q.exec(ctx, q.updateTrackStmt, updateTrack,
		arg.Name,
		arg.Country,
		arg.FkUpdatedByUserID,
		arg.ID,
	)
	return err
}
