// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: driver_link.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const getDriverLink = `-- name: GetDriverLink :one
SELECT
    driver_link.id,
    driver.name AS driver_name,
    "user".name AS user_name,
    driver_link.status,
    created_at
FROM
    driver_link
INNER JOIN "user" ON driver_link.fk_user_id = "user".id
INNER JOIN driver ON driver_link.fk_driver_id = driver.id
WHERE
    id = $1::BIGINT
`

type GetDriverLinkRow struct {
	ID         int64
	DriverName string
	UserName   string
	Status     sql.NullString
	CreatedAt  sql.NullTime
}

func (q *Queries) GetDriverLink(ctx context.Context, id int64) (GetDriverLinkRow, error) {
	row := q.queryRow(ctx, q.getDriverLinkStmt, getDriverLink, id)
	var i GetDriverLinkRow
	err := row.Scan(
		&i.ID,
		&i.DriverName,
		&i.UserName,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const insertDriverLink = `-- name: InsertDriverLink :one
INSERT INTO driver_link (
    fk_driver_id,
    fk_user_id,
    status,
    created_at
) VALUES (
    $1::BIGINT,
    $2::BIGINT,
    $3::VARCHAR,
    $4::TIMESTAMP
) RETURNING id::BIGINT
`

type InsertDriverLinkParams struct {
	FkDriverID int64
	FkUserID   int64
	Status     string
	CreatedAt  time.Time
}

func (q *Queries) InsertDriverLink(ctx context.Context, arg InsertDriverLinkParams) (int64, error) {
	row := q.queryRow(ctx, q.insertDriverLinkStmt, insertDriverLink,
		arg.FkDriverID,
		arg.FkUserID,
		arg.Status,
		arg.CreatedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const selectCountDriverLinks = `-- name: SelectCountDriverLinks :one
SELECT 
    COUNT(1) AS count
FROM
    driver_link
INNER JOIN "user" ON driver_link.fk_user_id = "user".id
INNER JOIN driver ON driver_link.fk_driver_id = driver.id
WHERE 
    CASE WHEN $1::VARCHAR != '' THEN 
        driver.name ILIKE '%' || $1 || '%' OR
        "user".name ILIKE '%' || $1 || '%'
    ELSE
        TRUE
    END
`

func (q *Queries) SelectCountDriverLinks(ctx context.Context, search string) (int64, error) {
	row := q.queryRow(ctx, q.selectCountDriverLinksStmt, selectCountDriverLinks, search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const selectDriverLinkStatusByUserID = `-- name: SelectDriverLinkStatusByUserID :one
SELECT
    driver_link.status::VARCHAR
FROM
    driver_link
WHERE
    fk_user_id = $1::BIGINT
`

func (q *Queries) SelectDriverLinkStatusByUserID(ctx context.Context, fkUserID int64) (string, error) {
	row := q.queryRow(ctx, q.selectDriverLinkStatusByUserIDStmt, selectDriverLinkStatusByUserID, fkUserID)
	var driver_link_status string
	err := row.Scan(&driver_link_status)
	return driver_link_status, err
}

const selectDriverLinks = `-- name: SelectDriverLinks :many
SELECT
    driver_link.id,
    driver.name AS driver_name,
    "user".name AS user_name,
    driver_link.status,
    created_at
FROM 
    driver_link
INNER JOIN "user" ON driver_link.fk_user_id = "user".id
INNER JOIN driver ON driver_link.fk_driver_id = driver.id
WHERE
    CASE WHEN $3::VARCHAR != '' THEN 
        driver.name ILIKE '%' || $3 || '%' OR
        "user".name ILIKE '%' || $3 || '%'
    ELSE
        TRUE
    END
ORDER BY 
    driver_link.id DESC
OFFSET $1
LIMIT $2
`

type SelectDriverLinksParams struct {
	Offset int32
	Limit  int32
	Search string
}

type SelectDriverLinksRow struct {
	ID         int64
	DriverName string
	UserName   string
	Status     sql.NullString
	CreatedAt  sql.NullTime
}

func (q *Queries) SelectDriverLinks(ctx context.Context, arg SelectDriverLinksParams) ([]SelectDriverLinksRow, error) {
	rows, err := q.query(ctx, q.selectDriverLinksStmt, selectDriverLinks, arg.Offset, arg.Limit, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SelectDriverLinksRow{}
	for rows.Next() {
		var i SelectDriverLinksRow
		if err := rows.Scan(
			&i.ID,
			&i.DriverName,
			&i.UserName,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
